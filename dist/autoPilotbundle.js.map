{"version":3,"file":"autoPilotbundle.js","mappings":";;;;;;;;;;;;;;;;;;AAAA;AAC0F;AAC1F;AAQwE;AACxE;AAMoE;AACpE;AAOuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sGAAa;AACzB,iBAAiB,yGAAW;AAC5B,aAAa,iGAAO;AACpB,gBAAgB,uGAAU;AAC1B,6GAAmB;AACnB,qHAAuB;AACvB,mHAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD;AACA,4GAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,cAAc;AACd;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,cAAc;AACd;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gGAAG;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iHAAoB;AACzC;AACA;AACA;AACA,iGAAG,CAAC,iGAAE;AACN;AACA,CAAC;AACD;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,MAAM,2GAAc;AACpB;AACA,yDAAyD;AACzD;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;;;;;;;;;;;;UC5NA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,IAAI;WACJ;WACA;WACA,IAAI;WACJ;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,CAAC;WACD;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,EAAE;WACF;WACA,sGAAsG;WACtG;WACA;WACA;WACA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA,EAAE;WACF;WACA;;;;;WChEA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;UENA;UACA;UACA;UACA","sources":["webpack:///./scripts/hospitalBay.js","webpack:///webpack/bootstrap","webpack:///webpack/runtime/async module","webpack:///webpack/runtime/make namespace object","webpack:///webpack/before-startup","webpack:///webpack/startup","webpack:///webpack/after-startup"],"sourcesContent":["// Import the functions you need from the SDKs you need\r\nimport { initializeApp } from \"https://www.gstatic.com/firebasejs/9.19.1/firebase-app.js\";\r\n\r\nimport {\r\n  getDatabase,\r\n  onValue,\r\n  set,\r\n  ref as db,\r\n  update,\r\n  connectDatabaseEmulator,\r\n} from \"https://www.gstatic.com/firebasejs/9.19.1/firebase-database.js\";\r\n\r\nimport {\r\n  getAuth,\r\n  onAuthStateChanged,\r\n  reauthenticateWithCredential,\r\n  connectAuthEmulator,\r\n} from \"https://www.gstatic.com/firebasejs/9.19.1/firebase-auth.js\";\r\n\r\nimport {\r\n  getStorage,\r\n  ref,\r\n  uploadBytesResumable,\r\n  connectStorageEmulator,\r\n  getDownloadURL,\r\n} from \"https://www.gstatic.com/firebasejs/9.19.1/firebase-storage.js\";\r\n// Your web app's Firebase configuration\r\n\r\nconst firebaseConfig = {\r\n  apiKey: \"AIzaSyBYGWKw0e1B-jhHmESHyxtjPKguhzQdFPg\",\r\n  authDomain: \"web3-44ce7.firebaseapp.com\",\r\n  databaseURL: \"https://web3-44ce7-default-rtdb.firebaseio.com\",\r\n  storageBucket: \"web3-44ce7.appspot.com\",\r\n};\r\n// Initialize Firebase\r\n\r\nconst app = initializeApp(firebaseConfig);\r\nconst database = getDatabase(app);\r\nconst auth = getAuth(app);\r\nconst storage = getStorage(app);\r\nconnectAuthEmulator(auth, \"http://localhost:8000\");\r\nconnectDatabaseEmulator(database, \"localhost\", 9000);\r\nconnectStorageEmulator(storage, \"localhost\", 9199);\r\n\r\n//Logout function\r\nconst endSession = document.getElementById(\"killSwitch\");\r\nendSession.addEventListener(\"click\", (f) => {\r\n  f.preventDefault();\r\n  auth.signOut().then(() => {\r\n    window.location.replace(\"../../Index.html\");\r\n  });\r\n});\r\n\r\nonAuthStateChanged(auth, (user) => {\r\n  if (user) {\r\n    // User is signed in, see docs for a list of available properties\r\n    // https://firebase.google.com/docs/reference/js/firebase.User\r\n    function getOriginFromUrl(url) {\r\n      // https://stackoverflow.com/questions/1420881/how-to-extract-base-url-from-a-string-in-javascript\r\n      const pathArray = url.split(\"/\");\r\n      const protocol = pathArray[0];\r\n      const host = pathArray[2];\r\n      return protocol + \"//\" + host;\r\n    }\r\n\r\n    // Get underlying body if available. Works for text and json bodies.\r\n    const getBodyContent = (req) => {\r\n      return Promise.resolve()\r\n        .then(() => {\r\n          if (req.method !== \"GET\") {\r\n            if (req.headers.get(\"Content-Type\").indexOf(\"json\") !== -1) {\r\n              return req.json().then((json) => {\r\n                return JSON.stringify(json);\r\n              });\r\n            } else {\r\n              return req.text();\r\n            }\r\n          }\r\n        })\r\n        .catch((error) => {\r\n          // Ignore error.\r\n        });\r\n    };\r\n\r\n    self.addEventListener(\"fetch\", (event) => {\r\n      /* @type {FetchEvent} ===========================>>>>>>>>>>>>here */\r\n      const evt = event;\r\n\r\n      const requestProcessor = (idToken) => {\r\n        let req = evt.request;\r\n        let processRequestPromise = Promise.resolve();\r\n        // For same origin https requests, append idToken to header.\r\n        if (\r\n          self.location.origin == getOriginFromUrl(evt.request.url) &&\r\n          (self.location.protocol == \"https:\" ||\r\n            self.location.hostname == \"localhost\") &&\r\n          idToken\r\n        ) {\r\n          // Clone headers as request headers are immutable.\r\n          const headers = new Headers();\r\n          req.headers.forEach((val, key) => {\r\n            headers.append(key, val);\r\n          });\r\n          // Add ID token to header.\r\n          headers.append(\"Authorization\", \"Bearer \" + idToken);\r\n          processRequestPromise = getBodyContent(req).then((body) => {\r\n            try {\r\n              req = new Request(req.url, {\r\n                method: req.method,\r\n                headers: headers,\r\n                mode: \"same-origin\",\r\n                credentials: req.credentials,\r\n                cache: req.cache,\r\n                redirect: req.redirect,\r\n                referrer: req.referrer,\r\n                body,\r\n                bodyUsed: req.bodyUsed,\r\n                context: req.context,\r\n              });\r\n            } catch (e) {\r\n              // This will fail for CORS requests. We just continue with the\r\n              // fetch caching logic below and do not pass the ID token.\r\n            }\r\n          });\r\n        }\r\n        return processRequestPromise.then(() => {\r\n          return fetch(req);\r\n        });\r\n      };\r\n      // Fetch the resource after checking for the ID token.\r\n      // This can also be integrated with existing logic to serve cached files\r\n      // in offline mode.\r\n      evt.respondWith(\r\n        getIdTokenPromise().then(requestProcessor, requestProcessor)\r\n      );\r\n    });\r\n    let header = document.getElementById(\"userDisplay\");\r\n    header.innerHTML = user.email;\r\n    // console.log(user.displayName + \" is logged in\");\r\n  } else {\r\n    // User is signed out\r\n    alert(\"You are logged out, please sign in/ register first\");\r\n    window.location.replace(\"../../offline_VS_Online/auth.html\");\r\n  }\r\n});\r\n\r\n// ADD CLICK LISTENER TO THE BUTTON WE SELECTED\r\nupdateCloud.addEventListener(\"click\", (g) => {\r\n  g.preventDefault();\r\n  // GET FILE FROM THE FILE INPUT\r\n  const file = document.getElementById(\"profileView\").files[0];\r\n\r\n  //Define cloud storage path for file\r\n  const storageRef = ref(storage, \"images/\" + file.name);\r\n  \r\n  //Define User\r\n  const currentMe = auth.currentUser;\r\n  const uploadedByDate = new Date();\r\n  const metadata = {\r\n    contentType: \"image/jpeg\",\r\n    Auther: uploadedByDate,\r\n    user: currentMe\r\n  };\r\n  const uploadTask = uploadBytesResumable(storageRef, file, metadata);\r\n\r\n  const msg = document.getElementById(\"broadcast\").value;\r\n//update database path for messages from text field\r\nset(db(database, \"users/\"), {\r\n  message: msg,\r\n})\r\n  .then(() => {\r\n    console.log(\"message sent\");\r\n  });\r\n\r\n  // Register three observers:\r\n  // 1. 'state_changed' observer, called any time the state changes\r\n  // 2. Error observer, called on failure\r\n  // 3. Completion observer, called on successful completion\r\n  uploadTask.on(\r\n    \"state_changed\",\r\n    (snapshot) => {\r\n      // Observe state change events such as progress, pause, and resume\r\n      // Get task progress, including the number of bytes uploaded and the total number of bytes to be uploaded\r\n      const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;\r\n      console.log(\"Upload is \" + progress + \"% done\");\r\n      switch (snapshot.state) {\r\n        case \"paused\":\r\n          console.log(\"Upload is paused\");\r\n          break;\r\n        case \"running\":\r\n          console.log(\"Upload is running\");\r\n          break;\r\n      }\r\n    },\r\n    (error) => {\r\n      // Handle unsuccessful uploads\r\n      alert(\r\n        \"⚠ Slow network is detected,  please check your internet connection & try again\"\r\n      );\r\n    },\r\n    () => {\r\n      // Handle successful uploads on complete\r\n      // For instance, get the download URL: https://firebasestorage.googleapis.com/...\r\n      getDownloadURL(uploadTask.snapshot.ref).then((downloadURL) => {\r\n        alert(\"✔ Message sent\");\r\n        //console.log(\"File available at\", downloadURL); <---------------This is a paid service \r\n        document.getElementById(\"broadcast\").value = \"\";\r\n        const fileInput = document.getElementById(\"profileView\");\r\n        fileInput.value = \"\";\r\n      });\r\n    }\r\n  );\r\n});\r\n\r\n\r\n\r\n// Function to upload message to Realtime Dat\r\nself.addEventListener(\"activate\", (event) => {\r\n  event.waitUntil(clients.claim());\r\n});\r\n\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","var webpackQueues = typeof Symbol === \"function\" ? Symbol(\"webpack queues\") : \"__webpack_queues__\";\nvar webpackExports = typeof Symbol === \"function\" ? Symbol(\"webpack exports\") : \"__webpack_exports__\";\nvar webpackError = typeof Symbol === \"function\" ? Symbol(\"webpack error\") : \"__webpack_error__\";\nvar resolveQueue = (queue) => {\n\tif(queue && !queue.d) {\n\t\tqueue.d = 1;\n\t\tqueue.forEach((fn) => (fn.r--));\n\t\tqueue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));\n\t}\n}\nvar wrapDeps = (deps) => (deps.map((dep) => {\n\tif(dep !== null && typeof dep === \"object\") {\n\t\tif(dep[webpackQueues]) return dep;\n\t\tif(dep.then) {\n\t\t\tvar queue = [];\n\t\t\tqueue.d = 0;\n\t\t\tdep.then((r) => {\n\t\t\t\tobj[webpackExports] = r;\n\t\t\t\tresolveQueue(queue);\n\t\t\t}, (e) => {\n\t\t\t\tobj[webpackError] = e;\n\t\t\t\tresolveQueue(queue);\n\t\t\t});\n\t\t\tvar obj = {};\n\t\t\tobj[webpackQueues] = (fn) => (fn(queue));\n\t\t\treturn obj;\n\t\t}\n\t}\n\tvar ret = {};\n\tret[webpackQueues] = x => {};\n\tret[webpackExports] = dep;\n\treturn ret;\n}));\n__webpack_require__.a = (module, body, hasAwait) => {\n\tvar queue;\n\thasAwait && ((queue = []).d = 1);\n\tvar depQueues = new Set();\n\tvar exports = module.exports;\n\tvar currentDeps;\n\tvar outerResolve;\n\tvar reject;\n\tvar promise = new Promise((resolve, rej) => {\n\t\treject = rej;\n\t\touterResolve = resolve;\n\t});\n\tpromise[webpackExports] = exports;\n\tpromise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise[\"catch\"](x => {}));\n\tmodule.exports = promise;\n\tbody((deps) => {\n\t\tcurrentDeps = wrapDeps(deps);\n\t\tvar fn;\n\t\tvar getResult = () => (currentDeps.map((d) => {\n\t\t\tif(d[webpackError]) throw d[webpackError];\n\t\t\treturn d[webpackExports];\n\t\t}))\n\t\tvar promise = new Promise((resolve) => {\n\t\t\tfn = () => (resolve(getResult));\n\t\t\tfn.r = 0;\n\t\t\tvar fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));\n\t\t\tcurrentDeps.map((dep) => (dep[webpackQueues](fnQueue)));\n\t\t});\n\t\treturn fn.r ? promise : getResult();\n\t}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));\n\tqueue && (queue.d = 0);\n};","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","","// startup\n// Load entry module and return exports\n// This entry module used 'module' so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./scripts/hospitalBay.js\");\n",""],"names":[],"sourceRoot":""}